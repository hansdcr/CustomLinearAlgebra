# 迭代计划详解

本文档详细规划了每个迭代的学习目标、数学背景、实现任务和验收标准。

## 阅读指南

每个迭代包含以下部分:
- **预计时长**: 建议投入时间
- **数学背景**: 用通俗语言解释的数学概念
- **实现任务**: 具体要编写的代码
- **可视化目标**: 要生成的图形效果
- **验收标准**: 如何判断迭代完成
- **VR/XR关联**: 与VR开发的联系

---

# 阶段一: 向量基础

## 迭代1: 2D向量类与可视化

**预计时长**: 1.5小时
**文件**: `src/core/vector2d.py`, `src/examples/iter01_vector2d_basic.py`

### 数学背景

**什么是向量?**

在编程中,你可能见过这样的代码:
```python
position = [10, 20]  # 角色在屏幕上的位置
```

这个列表其实就是一个**向量**!向量有两个理解角度:

1. **位置视角**: 向量表示从原点(0,0)到某个点(10,20)的位置
2. **方向+距离视角**: 向量表示"向右走10步,向上走20步"

在VR中,当你说"玩家在位置(1.5, 0, 2.3)",这就是一个3D向量。

**向量的基本操作**:
- **模(长度)**: 从原点到终点的距离,用勾股定理计算: √(x² + y²)
- **归一化**: 把向量变成长度为1但方向不变,相当于"只要方向,不要距离"

### 实现任务

1. **创建 `Vector2D` 类** (`src/core/vector2d.py`):
   ```python
   class Vector2D:
       def __init__(self, x: float, y: float):
           # 存储x, y坐标

       def magnitude(self) -> float:
           # 计算向量的长度(模)

       def normalize(self) -> 'Vector2D':
           # 返回归一化后的向量(单位向量)

       def __repr__(self) -> str:
           # 打印友好的字符串表示
   ```

2. **编写单元测试** (`tests/test_vector2d.py`):
   - 测试创建向量
   - 测试计算模: `Vector2D(3, 4).magnitude() == 5.0`
   - 测试归一化: 归一化后的向量长度为1

3. **创建可视化脚本** (`src/examples/iter01_vector2d_basic.py`):
   - 用 Matplotlib 绘制多个向量(箭头)
   - 展示原始向量和归一化后的向量
   - 标注向量的模

### 可视化目标

生成一张图,包含:
- 坐标系(带网格)
- 3-4个不同的2D向量(彩色箭头)
- 每个向量旁边标注其长度
- 展示其中一个向量归一化前后的对比

### 验收标准

- [ ] `Vector2D` 类能够正确创建和存储坐标
- [ ] 模的计算正确(用 `(3,4)` 向量测试,结果应为5)
- [ ] 归一化功能正确(归一化后长度为1)
- [ ] 所有单元测试通过
- [ ] 可视化脚本能够运行并生成清晰的图形

### VR/XR关联

在VR开发中:
- **位置向量**: 表示物体在3D空间中的坐标
- **方向向量**: 玩家的朝向、VR手柄的指向都是单位向量
- **归一化**: 在计算方向时必须归一化,否则速度会不一致

### 扩展思考

完成后可以尝试:
- 绘制一个向量从原点到鼠标位置(如果有GUI)
- 用向量表示一个简单的2D游戏角色的移动

---

## 迭代2: 向量加法与减法

**预计时长**: 1.5小时
**文件**: `src/core/vector2d.py`, `src/examples/iter02_vector_addition.py`

### 数学背景

**向量加法的几何意义**

假设你在地图上:
- 向量A = (3, 2): 向右走3步,向上走2步
- 向量B = (1, 4): 再向右走1步,向上走4步

结果位置就是 A + B = (4, 6)

**平行四边形法则**: 把两个向量首尾相连,或者以它们为邻边构成平行四边形,对角线就是和向量。

**向量减法**: A - B 表示"从B的终点指向A的终点的向量"

在VR中常用于:
- **位移计算**: 新位置 = 旧位置 + 速度向量 × 时间
- **计算方向**: 目标方向 = 目标位置 - 当前位置

### 实现任务

1. **扩展 `Vector2D` 类**:
   ```python
   def __add__(self, other: 'Vector2D') -> 'Vector2D':
       # 向量加法: (x1+x2, y1+y2)

   def __sub__(self, other: 'Vector2D') -> 'Vector2D':
       # 向量减法: (x1-x2, y1-y2)

   def __mul__(self, scalar: float) -> 'Vector2D':
       # 数乘: (x*scalar, y*scalar)
   ```

2. **扩展单元测试**:
   - 测试加法: `Vector2D(1,2) + Vector2D(3,4) == Vector2D(4,6)`
   - 测试减法
   - 测试数乘: `Vector2D(2,3) * 2 == Vector2D(4,6)`

3. **创建动画可视化** (`src/examples/iter02_vector_addition.py`):
   - 绘制向量A和B
   - 展示A + B的平行四边形法则
   - 展示A - B的几何意义
   - (可选)创建动画,展示向量相加的过程

### 可视化目标

生成两张图:

**图1 - 向量加法**:
- 绘制向量A(红色)和B(蓝色)
- 展示平行四边形构造
- 绘制和向量A+B(绿色)

**图2 - 向量减法**:
- 从同一起点绘制A和B
- 绘制A-B向量,展示它连接B的终点到A的终点

### 验收标准

- [ ] 向量加减法运算符重载正确实现
- [ ] 数乘运算正确
- [ ] 单元测试全部通过
- [ ] 可视化清晰展示平行四边形法则
- [ ] 能够解释为什么A-B是从B指向A

### VR/XR关联

**实际应用场景**:
```python
# VR头显位置更新
player_position = player_position + velocity * delta_time

# 计算敌人朝向玩家的方向
direction_to_player = player_position - enemy_position
direction_normalized = direction_to_player.normalize()
```

---

## 迭代3: 点积与投影

**预计时长**: 1.5-2小时
**文件**: `src/core/vector2d.py`, `src/examples/iter03_dot_product.py`

### 数学背景

**点积(内积)是什么?**

点积是两个向量之间的一种运算,结果是一个**数字**(不是向量):

```
A · B = Ax * Bx + Ay * By
```

但点积的几何意义更重要:

```
A · B = |A| × |B| × cos(θ)
```

其中θ是两个向量之间的夹角。

**点积的应用**:

1. **判断方向关系**:
   - A · B > 0: 夹角 < 90°,大致同向
   - A · B = 0: 夹角 = 90°,垂直
   - A · B < 0: 夹角 > 90°,大致反向

2. **投影**: 向量A在向量B方向上的投影长度 = (A · B) / |B|

**VR应用场景**:
- **视野判断**: 敌人是否在玩家视野内?(视线方向 · 敌人方向 > 0?)
- **表面判断**: 物体是面向相机还是背向相机?(表面法线 · 视线方向)
- **运动分解**: 在斜坡上,重力在斜坡方向的分量

### 实现任务

1. **扩展 `Vector2D` 类**:
   ```python
   def dot(self, other: 'Vector2D') -> float:
       # 点积: x1*x2 + y1*y2

   def angle(self, other: 'Vector2D') -> float:
       # 使用点积计算夹角(弧度): arccos((A·B)/(|A||B|))

   def project_onto(self, other: 'Vector2D') -> 'Vector2D':
       # 投影: 返回self在other方向上的投影向量
   ```

2. **单元测试**:
   - 测试点积: `Vector2D(1,0).dot(Vector2D(0,1)) == 0`(垂直)
   - 测试夹角计算
   - 测试投影功能

3. **可视化脚本**:
   - 绘制两个向量A和B
   - 展示它们的夹角
   - 绘制A在B方向上的投影
   - 用不同颜色区分投影前后

### 可视化目标

生成多个子图:

1. **子图1**: 展示两个向量的夹角(不同角度的例子)
2. **子图2**: 投影演示(绘制垂直虚线连接A的终点到投影点)
3. **子图3**: 点积符号的几何意义(同向/垂直/反向三种情况)

### 验收标准

- [ ] 点积计算正确
- [ ] 夹角计算正确(注意处理0向量情况)
- [ ] 投影功能正确
- [ ] 可视化清楚展示投影过程
- [ ] 能够用代码判断两个向量是否大致同向

### VR/XR关联

**实战代码示例**:
```python
# 判断敌人是否在玩家视野内(前方120度范围)
player_forward = get_forward_direction()
to_enemy = (enemy_pos - player_pos).normalize()

if player_forward.dot(to_enemy) > 0.5:  # cos(60°) ≈ 0.5
    print("敌人在视野内!")
```

---

## 迭代4: 3D向量类

**预计时长**: 2小时
**文件**: `src/core/vector3d.py`, `src/examples/iter04_vector3d_basic.py`

### 数学背景

**从2D到3D**

3D向量只是多了一个z坐标: `(x, y, z)`

但这一步对VR至关重要,因为:
- VR世界是3D的
- 所有物体的位置、旋转、朝向都用3D向量表示

**坐标系约定** (Unity/Unreal风格):
- **X轴**: 左(-) / 右(+)
- **Y轴**: 下(-) / 上(+)
- **Z轴**: 后(-) / 前(+)

这是**左手坐标系**。某些引擎用右手坐标系(如OpenGL),但数学原理相同。

### 实现任务

1. **创建 `Vector3D` 类** (`src/core/vector3d.py`):
   - 复制 `Vector2D` 的所有功能
   - 扩展到三维: `x, y, z`
   - 实现所有运算: 加减、数乘、点积、模、归一化

2. **3D投影辅助函数** (`src/visualization/projection.py`):
   ```python
   def project_3d_to_2d(point: Vector3D,
                        rotation_x: float,
                        rotation_y: float) -> tuple:
       # 简单的正交投影,用于在2D屏幕显示3D点
       # 这个迭代先不用太复杂,后续会详细实现
   ```

3. **3D可视化** (`src/examples/iter04_vector3d_basic.py`):
   - 使用 Matplotlib 3D 绘图
   - 绘制3D坐标系(XYZ轴)
   - 绘制多个3D向量
   - 可以旋转视角查看

### 可视化目标

生成交互式3D图:
- 3D坐标轴(X红色, Y绿色, Z蓝色)
- 3-4个3D向量从原点出发
- 标注向量长度
- 可以用鼠标旋转视角

### 验收标准

- [ ] `Vector3D` 类功能完整
- [ ] 所有2D向量的功能在3D中正常工作
- [ ] 3D可视化能够正确显示向量
- [ ] 理解3D坐标系的含义

### VR/XR关联

从这个迭代开始,所有代码都直接适用于VR开发:
- VR头显位置: `Vector3D`
- VR手柄位置: `Vector3D`
- 物体朝向: `Vector3D` (单位向量)

---

## 迭代5: 叉积与右手法则

**预计时长**: 1.5-2小时
**文件**: `src/core/vector3d.py`, `src/examples/iter05_cross_product.py`

### 数学背景

**叉积是3D专属**

2D向量没有叉积(或者说结果是0维的)。叉积的结果是一个**向量**:

```
A × B = (Ay*Bz - Az*By, Az*Bx - Ax*Bz, Ax*By - Ay*Bx)
```

**叉积的几何意义**:

1. **垂直**: A × B 的结果垂直于A和B组成的平面
2. **方向**: 使用"右手法则"确定方向
   - 右手四指从A转向B
   - 大拇指指向就是 A × B 的方向
3. **大小**: |A × B| = |A| × |B| × sin(θ)
   - 等于A和B组成的平行四边形面积

**VR应用**:
- **计算法线**: 三角形面的法线 = edge1 × edge2
- **判断左右**: 目标在我左边还是右边?
- **计算旋转轴**: 从A旋转到B,旋转轴 = A × B

### 实现任务

1. **扩展 `Vector3D` 类**:
   ```python
   def cross(self, other: 'Vector3D') -> 'Vector3D':
       # 叉积公式实现

   def is_perpendicular(self, other: 'Vector3D', tolerance=1e-6) -> bool:
       # 判断是否垂直(点积接近0)
   ```

2. **单元测试**:
   - 测试基本轴: `Vector3D(1,0,0).cross(Vector3D(0,1,0)) == Vector3D(0,0,1)`
   - 测试垂直性: `A.dot(A.cross(B)) == 0`
   - 测试反交换律: `A × B = -(B × A)`

3. **3D可视化**:
   - 绘制向量A(红色)和B(蓝色)
   - 绘制它们组成的平面(半透明)
   - 绘制叉积结果C(绿色),展示其垂直性
   - 可选: 绘制右手演示图

### 可视化目标

生成3D动态图:
- 两个向量A和B
- 它们的叉积C
- 展示C垂直于A和B
- (可选)动画演示右手法则

### 验收标准

- [ ] 叉积计算正确
- [ ] 验证叉积的垂直性(点积为0)
- [ ] 理解右手法则
- [ ] 能够用叉积判断左右方向

### VR/XR关联

**计算三角形法线**(用于光照):
```python
# 三角形的三个顶点: p1, p2, p3
edge1 = p2 - p1
edge2 = p3 - p1
normal = edge1.cross(edge2).normalize()
```

**判断目标在左边还是右边**:
```python
forward = player_forward
to_target = (target_pos - player_pos).normalize()
cross = forward.cross(to_target)

if cross.y > 0:
    print("目标在左边")
else:
    print("目标在右边")
```

---

## 迭代6: 向量综合应用

**预计时长**: 2小时
**文件**: `src/examples/iter06_vector_applications.py`

### 数学背景

综合前5个迭代的知识,实现几个实际应用。

### 实现任务

实现以下4个小工具/演示:

1. **2D粒子系统**:
   - 从中心发射粒子(随机方向的单位向量)
   - 粒子有速度向量和加速度向量(模拟重力)
   - 用Matplotlib绘制轨迹动画

2. **3D平面检测**:
   - 给定一个点和一个平面(用法线表示)
   - 判断点在平面的哪一侧(用点积)

3. **视野检测器**:
   - 模拟一个3D角色
   - 判断哪些目标在其视野锥内

4. **简单的3D相机朝向**:
   - 给定目标位置,计算相机的forward/right/up向量
   - (这是lookAt的简化版,完整版在迭代30)

### 可视化目标

为每个应用生成演示:
1. 粒子轨迹动画(GIF或连续图像)
2. 平面和点的3D关系图
3. 视野锥可视化
4. 相机坐标系可视化

### 验收标准

- [ ] 粒子系统能够正确模拟物理运动
- [ ] 平面检测功能正确
- [ ] 视野检测能够正确判断
- [ ] 理解如何构建正交的坐标系(forward/right/up)

### VR/XR关联

这些都是VR引擎中的基础功能:
- 粒子系统: 特效(火花、烟雾)
- 平面检测: 碰撞检测基础
- 视野检测: AI感知系统
- 相机坐标: VR相机控制

---

## 迭代7-10: 过渡到矩阵

**简要说明**:

- **迭代7**: 理解线性变换的概念,手动实现2D旋转
- **迭代8**: 创建 `Matrix` 类,实现矩阵乘法
- **迭代9**: 2D变换矩阵(旋转、缩放、剪切)
- **迭代10**: 齐次坐标与平移变换

(详细内容继续...)

---

# 阶段二: 矩阵与线性变换

## 迭代11: Matrix类核心实现

**预计时长**: 2小时
**文件**: `src/core/matrix.py`, `tests/test_matrix.py`

### 数学背景

**矩阵是什么?**

简单理解,矩阵就是一个数字表格:

```
┌         ┐
│ 1  2  3 │
│ 4  5  6 │
└         ┘
```

这是一个 2×3 矩阵(2行3列)。

**但矩阵的核心意义是: 线性变换!**

在计算机图形学中,矩阵用来表示"对向量的操作":
- 旋转矩阵: 让向量旋转
- 缩放矩阵: 让向量变长或变短
- 投影矩阵: 把3D向量投影到2D屏幕

**矩阵乘法**:

矩阵 × 向量 = 变换后的向量

```python
rotation_matrix * point_vector = rotated_point
```

### 实现任务

1. **创建通用 `Matrix` 类**:
   ```python
   class Matrix:
       def __init__(self, data: List[List[float]]):
           # 存储二维列表
           # self.rows, self.cols

       def __mul__(self, other):
           # 矩阵乘法或矩阵-向量乘法

       def transpose(self) -> 'Matrix':
           # 矩阵转置

       def identity(size: int) -> 'Matrix':
           # 创建单位矩阵

       @staticmethod
       def from_rows(rows: List[List[float]]) -> 'Matrix':
           # 从行列表创建
   ```

2. **矩阵-向量乘法**:
   ```python
   def multiply_vector(self, vec: Vector3D) -> Vector3D:
       # 实现矩阵 × 向量运算
   ```

3. **单元测试**:
   - 测试矩阵创建
   - 测试单位矩阵(乘以任何向量不变)
   - 测试矩阵乘法
   - 测试转置

### 可视化目标

这个迭代暂时不需要复杂可视化,可以打印矩阵到控制台:

```
Matrix 3×3:
[ 1.00  0.00  0.00 ]
[ 0.00  1.00  0.00 ]
[ 0.00  0.00  1.00 ]
```

### 验收标准

- [ ] `Matrix` 类能够存储任意大小的矩阵
- [ ] 矩阵乘法正确实现(包括维度检查)
- [ ] 单位矩阵功能正确
- [ ] 所有单元测试通过

### VR/XR关联

矩阵是3D图形的核心:
- VR中所有的变换都通过矩阵完成
- 渲染管线本质上是一系列矩阵乘法

---

## 迭代12: 2D旋转矩阵

**预计时长**: 1.5小时
**文件**: `src/graphics/transform2d.py`, `src/examples/iter12_rotation_matrix.py`

### 数学背景

**2D旋转矩阵公式**:

将点(x, y)绕原点逆时针旋转θ角度:

```
┌              ┐   ┌   ┐   ┌                           ┐
│ cos(θ) -sin(θ)│   │ x │   │ x*cos(θ) - y*sin(θ) │
│ sin(θ)  cos(θ)│ × │ y │ = │ x*sin(θ) + y*cos(θ) │
└              ┘   └   ┘   └                           ┘
```

**为什么是这个公式?**

当你用三角函数在单位圆上表示角度时,旋转就是这样的线性组合。(如果想深入理解,可以查看《3Blue1Brown》的线性代数视频)

### 实现任务

1. **创建2D变换模块** (`src/graphics/transform2d.py`):
   ```python
   def rotation_matrix_2d(angle: float) -> Matrix:
       # 创建2D旋转矩阵(角度单位: 弧度)
       # 返回 2×2 矩阵

   def apply_transform(matrix: Matrix,
                       points: List[Vector2D]) -> List[Vector2D]:
       # 对一组点应用变换
   ```

2. **可视化脚本**:
   - 绘制一个2D形状(如正方形或三角形)
   - 应用旋转矩阵,绘制旋转后的形状
   - 创建动画,展示连续旋转过程
   - 显示旋转角度

### 可视化目标

生成动画或多帧图像:
- 原始形状(蓝色)
- 旋转后的形状(红色)
- 显示旋转中心(原点)
- 显示旋转角度
- (可选)创建360度旋转动画

### 验收标准

- [ ] 旋转矩阵公式正确实现
- [ ] 能够正确旋转任意2D点
- [ ] 验证: 旋转90度后,(1,0)变为(0,1)
- [ ] 可视化清晰展示旋转效果

### VR/XR关联

虽然VR是3D的,但理解2D旋转是基础:
- 2D旋转矩阵是3D旋转矩阵的简化版
- UI元素在屏幕上的旋转使用2D变换

---

## 迭代13: 2D缩放和剪切矩阵

**预计时长**: 1.5小时
**文件**: `src/graphics/transform2d.py`, `src/examples/iter13_scale_shear.py`

### 数学背景

**缩放矩阵**:

```
┌        ┐
│ sx  0  │  其中 sx, sy 是x和y方向的缩放因子
│ 0   sy │
└        ┘
```

例如: sx=2, sy=0.5 会让形状在x方向拉伸2倍,y方向压缩到一半。

**剪切(错切)矩阵**:

```
┌       ┐
│ 1  shx│  shx控制x方向的剪切
│ 0   1 │
└       ┘
```

剪切会让矩形变成平行四边形,像推牌一样。

### 实现任务

1. **扩展 `transform2d.py`**:
   ```python
   def scale_matrix_2d(sx: float, sy: float) -> Matrix:
       # 缩放矩阵

   def shear_matrix_2d(shx: float, shy: float) -> Matrix:
       # 剪切矩阵
   ```

2. **可视化不同变换**:
   - 在一张图中展示多个子图
   - 原始形状 / 缩放后 / 剪切后
   - 对比效果

### 可视化目标

2×2子图布局:
- 左上: 原始正方形
- 右上: 缩放变换(如 2×放大,0.5×缩小)
- 左下: 剪切变换X
- 右下: 剪切变换Y

### 验收标准

- [ ] 缩放矩阵功能正确
- [ ] 剪切矩阵功能正确
- [ ] 理解各个变换的几何效果
- [ ] 可视化对比清晰

### VR/XR关联

- **缩放**: 物体大小调整,VR中的手势缩放
- **剪切**: 较少直接使用,但在高级动画(骨骼蒙皮)中会出现

---

## 迭代14: 变换组合与顺序

**预计时长**: 2小时
**文件**: `src/examples/iter14_transform_composition.py`

### 数学背景

**变换的组合就是矩阵相乘**

如果你想先缩放再旋转:
```python
combined = rotation_matrix × scale_matrix
result = combined × point
```

**关键问题: 矩阵乘法不满足交换律!**

```
A × B ≠ B × A
```

这意味着:
- 先缩放再旋转 ≠ 先旋转再缩放
- 变换顺序至关重要!

**VR开发中的常见错误**: 变换顺序搞错导致物体出现在错误位置。

### 实现任务

1. **实现变换组合工具**:
   ```python
   class Transform2D:
       def __init__(self):
           self.matrix = Matrix.identity(3)  # 使用齐次坐标

       def rotate(self, angle: float) -> 'Transform2D':
           # 链式调用: transform.rotate(45).scale(2, 2)

       def scale(self, sx: float, sy: float) -> 'Transform2D':

       def translate(self, dx: float, dy: float) -> 'Transform2D':

       def apply(self, point: Vector2D) -> Vector2D:
   ```

2. **演示变换顺序的影响**:
   - 创建两个变换序列:
     - 序列A: 平移 → 旋转
     - 序列B: 旋转 → 平移
   - 对同一个形状应用,展示不同结果

### 可视化目标

并排对比图:
- 原始形状(中心不在原点)
- 序列A结果: 先平移后旋转
- 序列B结果: 先旋转后平移
- 清晰标注变换顺序

### 验收标准

- [ ] 变换组合功能正确
- [ ] 理解矩阵乘法的顺序
- [ ] 能够预测变换组合的结果
- [ ] 链式API使用方便

### VR/XR关联

**Unity/Unreal中的Transform组件**:
```csharp
// Unity中常见的错误
transform.Rotate(...);  // 旋转
transform.Translate(...);  // 平移
// 这两行的顺序会影响最终结果!
```

在VR开发中,通常的变换顺序是:
1. 缩放(Scale)
2. 旋转(Rotation)
3. 平移(Translation)

记忆口诀: SRT

---

## 迭代15: 齐次坐标系统

**预计时长**: 2小时
**文件**: `src/core/vector2d.py`, `src/graphics/transform2d.py`

### 数学背景

**问题: 平移不是线性变换**

前面的旋转、缩放、剪切都能用 2×2 矩阵表示,但平移不行:

```
(x, y) → (x + dx, y + dy)
```

这不能写成矩阵乘法的形式!

**解决方案: 齐次坐标**

在2D中,我们给每个点增加一个额外的坐标:

```
(x, y) → (x, y, 1)
```

现在平移可以这样表示:

```
┌          ┐   ┌   ┐   ┌       ┐
│ 1  0  dx │   │ x │   │ x+dx  │
│ 0  1  dy │ × │ y │ = │ y+dy  │
│ 0  0  1  │   │ 1 │   │  1    │
└          ┘   └   ┘   └       ┘
```

现在所有2D变换都可以用 3×3 矩阵表示!

### 实现任务

1. **更新向量类支持齐次坐标**:
   ```python
   class Vector2D:
       def to_homogeneous(self) -> List[float]:
           # 返回 [x, y, 1]

       @staticmethod
       def from_homogeneous(coords: List[float]) -> 'Vector2D':
           # 从 [x, y, w] 恢复为 [x/w, y/w]
   ```

2. **更新所有变换矩阵为3×3**:
   ```python
   def rotation_matrix_2d(angle: float) -> Matrix:
       # 返回 3×3 矩阵
       # ┌ cos -sin 0 ┐
       # │ sin  cos 0 │
       # └  0    0  1 ┘

   def translation_matrix_2d(dx: float, dy: float) -> Matrix:
       # 终于可以实现平移矩阵了!
   ```

3. **验证齐次坐标的威力**:
   - 实现复杂变换组合(包含平移)
   - 验证所有变换都能统一用矩阵乘法

### 可视化目标

演示齐次坐标的必要性:
- 展示一个复杂变换: 平移→旋转→缩放→平移
- 只需一个组合矩阵即可完成

### 验收标准

- [ ] 齐次坐标转换正确
- [ ] 平移矩阵正确实现
- [ ] 所有2D变换统一为3×3矩阵
- [ ] 理解齐次坐标的意义

### VR/XR关联

齐次坐标是3D图形的基础:
- 3D中使用4×4矩阵(x, y, z, w)
- GPU渲染管线全程使用齐次坐标
- 理解齐次坐标后,3D变换就很自然了

---

## 迭代16-20: 3D变换矩阵

**简要规划**:

- **迭代16**: 实现3D旋转矩阵(绕X/Y/Z轴)
- **迭代17**: 欧拉角与万向锁问题
- **迭代18**: 3D变换组合与4×4矩阵
- **迭代19**: 实现简单的3D物体渲染器
- **迭代20**: 交互式3D变换工具

---

## 迭代21: 矩阵的逆与行列式

**预计时长**: 2小时
**文件**: `src/core/matrix.py`, `src/examples/iter21_inverse.py`

### 数学背景

**逆矩阵的意义: 撤销变换**

如果矩阵M代表一个变换,那么它的逆矩阵M⁻¹代表"反向变换":

```
M × M⁻¹ = I (单位矩阵)
```

**实际应用**:
- 你把物体旋转了30度,逆矩阵可以把它转回来
- 世界坐标 → 相机坐标用矩阵M,那么相机坐标 → 世界坐标用M⁻¹

**行列式**:

行列式是一个数字,表示矩阵对空间的"缩放因子":
- det(M) = 0: 矩阵不可逆(把空间压扁了)
- det(M) < 0: 矩阵改变了坐标系的手性(左手变右手)

### 实现任务

1. **实现行列式计算** (从2×2开始):
   ```python
   def determinant(self) -> float:
       # 2×2: ad - bc
       # 3×3: 使用余子式展开
       # 4×4: 递归或使用LU分解
   ```

2. **实现矩阵求逆** (使用高斯-约旦消元法):
   ```python
   def inverse(self) -> 'Matrix':
       # 检查行列式是否为0
       # 使用增广矩阵法求逆
   ```

3. **验证逆矩阵性质**:
   ```python
   M = random_matrix()
   M_inv = M.inverse()
   assert M * M_inv ≈ Identity
   ```

### 可视化目标

演示变换和逆变换:
- 绘制形状变换过程: 原始 → 变换 → 逆变换
- 展示变换往返后形状不变

### 验收标准

- [ ] 行列式计算正确
- [ ] 矩阵求逆功能正确
- [ ] 验证 M × M⁻¹ = I
- [ ] 能够用逆矩阵撤销变换

### VR/XR关联

逆矩阵在VR中无处不在:
- 视图矩阵 = 相机变换矩阵的逆
- 从屏幕射线追踪到世界空间需要投影矩阵的逆
- 骨骼动画中的绑定姿态矩阵与当前姿态矩阵互逆

---

## 迭代22-25: 矩阵深入

**简要规划**:

- **迭代22**: 矩阵转置与正交矩阵
- **迭代23**: 旋转矩阵的性质
- **迭代24**: 实现简单的矩阵分解(LU分解)
- **迭代25**: 线性方程组求解(高斯消元法)

---

# 阶段三: 坐标系与投影

## 迭代26-30: 坐标空间变换

(详细内容...)

- **迭代26**: 理解模型/世界/视图/投影空间
- **迭代27**: 实现LookAt矩阵(相机朝向)
- **迭代28**: 透视投影矩阵
- **迭代29**: 正交投影矩阵
- **迭代30**: 视锥体裁剪

---

## 迭代31-35: 3D渲染管线

(详细内容...)

- **迭代31**: 完整的变换管线
- **迭代32**: 简单的光栅化
- **迭代33**: Z-Buffer深度测试
- **迭代34**: 使用PyVista实现高级渲染
- **迭代35**: 交互式3D场景编辑器

---

# 阶段四: 高级主题

## 迭代36-40: 四元数

(详细内容...)

- **迭代36**: 四元数基础
- **迭代37**: 四元数旋转
- **迭代38**: 四元数插值(Slerp)
- **迭代39**: 欧拉角↔四元数转换
- **迭代40**: 解决万向锁问题

---

## 迭代41-45: 高级矩阵理论

(详细内容...)

- **迭代41**: 特征值与特征向量
- **迭代42**: 对角化
- **迭代43**: SVD奇异值分解
- **迭代44**: PCA主成分分析
- **迭代45**: 矩阵在机器学习中的应用

---

## 迭代46-50: 综合应用

(详细内容...)

- **迭代46**: 实现简单的物理引擎(刚体动力学)
- **迭代47**: 碰撞检测与响应
- **迭代48**: 骨骼动画的数学基础
- **迭代49**: 网格变形与蒙皮
- **迭代50**: 光线追踪基础

---

# 阶段五: 开放式项目

## 迭代51+: 自选方向

根据你的兴趣,可以选择以下方向深入:

### 方向A: VR/XR专项
- 立体渲染(双目视差)
- 手部追踪数学
- 空间音频定位
- 传送机制的平滑过渡

### 方向B: 游戏引擎
- 完整的场景图系统
- 粒子系统
- 地形渲染
- 相机控制系统

### 方向C: 数据可视化
- 高维数据降维
- 交互式图表
- 科学计算可视化

### 方向D: 机器学习
- 线性回归从零实现
- 神经网络的矩阵运算
- 图像变换与增强

---

## 附录: 快速参考

### 常用矩阵公式

**2D旋转** (角度θ):
```
[ cos(θ)  -sin(θ) ]
[ sin(θ)   cos(θ) ]
```

**3D绕Z轴旋转**:
```
[ cos(θ)  -sin(θ)  0 ]
[ sin(θ)   cos(θ)  0 ]
[   0        0     1 ]
```

**缩放矩阵**:
```
[ sx   0   0 ]
[  0  sy   0 ]
[  0   0  sz ]
```

**平移矩阵** (齐次坐标):
```
[ 1  0  0  dx ]
[ 0  1  0  dy ]
[ 0  0  1  dz ]
[ 0  0  0   1 ]
```

---

## 使用建议

1. **不要跳跃**: 迭代是精心设计的递进顺序
2. **动手实践**: 每个迭代都要运行代码,观察结果
3. **遇到困难不要气馁**: 记录问题,继续前进,稍后回顾
4. **建立知识联系**: 经常回顾前面的迭代,建立知识网络
5. **灵活调整**: 如果某个迭代特别有趣,可以多花时间深入

祝学习顺利!
